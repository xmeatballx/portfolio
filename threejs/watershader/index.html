<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>LoFi Water Shader</title><script defer="defer" src="main.js"></script><link href="main.css" rel="stylesheet"></head><body><canvas class="webgl"></canvas><script type="x-shader/x-vertex" id="vertexShader">varying vec4 norm;
        varying vec3 fragPos;
        uniform vec2 resolution;
        uniform float time;
        varying float m_dist;

        vec2 random2( vec2 p ) {
    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}

mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

void main()
{
  vec2 st = position.xy/uv;
  st.x *= resolution.x/resolution.y;
  st *= 50.;

  vec2 i_st = floor(st);
  vec2 f_st = fract(st);

  m_dist = 1.;  // minimum distance

    #pragma unroll_loop_start
    for (int y= -1; y <= 1; y++) {
        #pragma unroll_loop_start
        for (int x= -1; x <= 1; x++) {
            // Neighbor place in the grid
            vec2 neighbor = vec2(float(x),float(y));

            // Random position from current + neighbor place in the grid
            vec2 point = random2(i_st + neighbor);

            // Animate the point
            point = 0.5 + 0.5*sin(time + 6.2831*point);

            // Vector between the pixel and the point
            vec2 diff = neighbor + point - f_st;

            // Distance to the point
            float dist = length(diff);

            // Keep the closer distance
            m_dist = min(m_dist, dist);
        }
        #pragma unroll_loop_end
    }
    #pragma unroll_loop_end

  vec3 P = position; 
  vec3 N = normal; 

  P = (rotationMatrix(vec3(1,0,0), 3.14/2.0)*vec4(P,1.0)).xyz;
  N = (rotationMatrix(vec3(1,0,0), 3.14/2.0)*vec4(N,1.0)).xyz;
  
  mat4 modelView = viewMatrix * modelMatrix;
  mat4 modelViewProjection = projectionMatrix * modelView;
  gl_Position = modelViewProjection * vec4(P.x, P.y+(m_dist/20.), P.z, 1.0);
  
  norm = modelView * vec4(N, 0.0);
  fragPos = vec3(modelMatrix*vec4(P, 1.0));
  //fragPos = vec3(gl_Position);
}</script><script type="x-shader/x-vertex" id="fragmentShader">// Author: @patriciogv
// Title: CellularNoise

uniform vec2 resolution;
uniform vec2 u_mouse;
uniform float time;
varying vec4 norm;
varying vec3 fragPos;
varying float m_dist;

vec2 random2( vec2 p ) {
    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}

void main() {
    vec2 st = gl_FragCoord.xy/resolution.xy;
    st.x *= resolution.x/resolution.y;
    vec3 color = vec3(.0);
    vec3 normie = normalize(vec3(norm));
    vec3 lightPos = vec3(0,50,cameraPosition.y*-10.);
    vec3 lightDir = normalize(lightPos-fragPos);

    float diff = max(dot(normie, lightDir), 0.5);
    vec3 diffuse = diff * vec3(.1,.1,.1);

    vec3 viewPos = cameraPosition;
    float specularStrength = 1.0;
    vec3 viewDir = normalize(viewPos-fragPos);
    vec3 reflectDir = reflect(-lightDir, normie);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec3 specular = specularStrength * spec * vec3(.2,.2,.2); 


    // Draw the min distance (distance field)
    //color += m_dist;
    color = diffuse+specular+vec3(0,0,.5)+(m_dist/4.)-(-fragPos.z/200.);

    // Draw cell center
    //color += 1.-step(.02, m_dist);

    // Draw grid
    //color.r += step(.98, f_st.x) + step(.98, f_st.y);

    // Show isolines
    color = mix(color,vec3(abs(sin(10.0*m_dist))),0.1);

    gl_FragColor = vec4(color,1.0);
}</script></body></html>